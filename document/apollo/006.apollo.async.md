# 潘多拉魔盒：异步

>  敕勒川，阴山下。天似穹庐，笼盖四野。天苍苍，野茫茫，风吹草低见牛羊。 ——南北《敕勒歌》

* 项目地址：<https://github.com/silentbalanceyh/vertx-zero-example/>（子项目：**up-rhea**）

##  「壹」异步原理

&ensp;&ensp;&ensp;&ensp;到目前为止，所有的代码示例都是**同步（Sync）**的，代码并没有真正释放Zero框架和Vert.x的魔力，本章节就是彻底地放飞，把这个**潘多拉**魔盒打开。在Vert.x中，我们通常会把一份数据、一个包含数据的请求统称为Event（事件），所以本章将会讲解Zero中最核心的内容——事件驱动模型（Event Drivent Model）。

### 1.1. 风格综述

&ensp;&ensp;&ensp;&ensp;在网络消息交互模式中，通常会有下边四种（参考WSDL规范）：

* Request-Response：请求/响应模式。
    ![](./_image/2021-08-02/2021-08-02-20-29-51.jpg)
* Solicit-Response：发布/订阅模式。
    ![](./_image/2021-08-02/2021-08-02-20-30-19.jpg)
* One-Way：单向请求模式。
    ![](./_image/2021-08-02/2021-08-02-20-30-00.jpg)
* Notification：提醒模式。
    ![](./_image/2021-08-02/2021-08-02-20-30-08.jpg)

>  图片引用地址：<https://help.perforce.com/hydraexpress/4.3.0/html/rwsfexpwsfabricationug/9-2.html>

&ensp;&ensp;&ensp;&ensp;Zero中针对上述四种模式分成了四种类型：

|名称|模式|使用场景|
|---|---|:---|
|标准流|Request-Response|「高频」通常使用的RESTful API。|
|单向流|One-Way|不关心任何请求结果的RESTful API。|
|检测流|One-Way|检测远程服务器是否合法（通常仅发送Header请求）。|

> 由于Solicit-Response模式和Notification模式都是服务端主动触发，这两种模式目前Zero的版本还不支持（和作者接触的项目需求有关）。

&ensp;&ensp;&ensp;&ensp;Zero中对编程风格的划分主要基于三个维度：

1. Java语言：是interface类还是class类。
2. Vert.x工具集：是否启用EventBus。
3. WSDL规范：是否关心响应。

&ensp;&ensp;&ensp;&ensp;本章之后章节会讲解**八种风格**中Zero推荐和高频使用的编程风格。

### 1.2. Zero模式

&ensp;&ensp;&ensp;&ensp;Vert.x中的Verticle组件主要分为两种类型：EventLoop和Worker，根据这两类组件的特征，最终Zero对组件职责进行了重新定义：

|线程类型|组件名|Lambda组件|含义/职责|
|---|:---|:---|:---|
|EventLoop|Agent组件|发送者Sender|接收请求、同步执行、发送异步请求到EventBus|
|Worker|Worker组件|消费者Consumer|消费EventBus请求、异步执行、生成响应|

&ensp;&ensp;&ensp;&ensp;Zero最终支持五种核心的请求模式。

#### 1.2.1. Sync - 同步模式

**流程图**

![](./_image/2021-08-02/request-mode1.png)

**代码**

```java
    @GET
    @Path("/sync")
    public String doSync(
            @QueryParam("name") final String name
    ) {
        return "Hi + " + name;
    }
```

**限制规则**

* 方法定义的返回类型（return）**不能是**`void`。
* 不使用`@Address`注解（Zero专用注解`io.vertx.up.annotations.Address`）。

#### 1.2.2. Ping - 信号模式

**流程图**

![](./_image/2021-08-02/request-mode2.png)

**代码**

```java
    @GET
    @Path("/ping/{name}")
    public void doPing(
            @PathParam("name") final String name) {
        System.out.println("Ping Request");
    }
```

**限制规则**

* 方法定义的返回类型（return）**必须是**`void`。
* 该方法只会收到类似`true/false`的响应信息，并不会得到任何和**代码逻辑**相关的响应数据。

#### 1.2.3. OneWay - 单向模式

**流程图**

![](./_image/2021-08-02/request-mode3.png)

**代码：Sender发送者**

```java
    @POST
    @Path("/one-way")
    @Address("ZERO://ONE-WAY")
    public String sendOneWay(
            @BodyParam final JsonObject json) {
        return json.encode();
    }
```

**代码：Consumer消费者**

```java
    @Address("ZERO://ONE-WAY")
    public void reply(final Envelop message) {
        final JsonObject data = Ux.getJson(message);
        // Do somethings
        System.out.println(data.encodePrettily());
    }
```

**限制规则**

* 该模式中使用了Zero的三个核心注解：
    * Agent组件：`io.vertx.up.annotations.EndPoint`。
    * Worker组件：`io.vertx.up.annotations.Queue`。
    * EventBus地址：`io.vertx.up.annotations.Address`。
* EndPoint注解的Agent组件方法不能使用`void`的返回值。
* Worker签名必须符合Zero中的Worker方法签名规范，并且返回值**必须是**`void`。

#### 1.2.4. Standard - 标准模式

**流程图**

![](./_image/2021-08-02/request-mode4.png)

**代码：Sender发送者**

```java
    @POST
    @Path("/async")
    @Address("ZERO://ASYNC")
    public String sendAsync(
            @BodyParam final JsonObject json) {
        return json.encode();
    }
```

**代码：Consumer消费者**

```java
    @Address("ZERO://ASYNC")
    public Envelop replyAsync(final Envelop message) {
        final JsonObject data = Ux.getJson(message);
        // Do somethings
        return Envelop.success(data);
    }
```

**限制规则**

* 该模式中使用了Zero的三个核心注解：
    * Agent组件：`io.vertx.up.annotations.EndPoint`。
    * Worker组件：`io.vertx.up.annotations.Queue`。
    * EventBus地址：`io.vertx.up.annotations.Address`。
* EndPoint注解的Agent组件方法不能使用`void`的返回值。
* Worker签名必须符合Zero中的Worker方法签名规范，并且返回值**不能是**`void`。

#### 1.2.5. Callback - 回调模式

**流程图**

![](./_image/2021-08-02/request-mode5.png)

**代码：Sender发送者**

```java
    @Path("/callback")
    @POST
    @Address("ZERO://CALLBACK")
    public JsonObject sayCallback(
            @BodyParam final JsonObject data) {
        return data;
    }
```

**代码：Consumer消费者**

```java
    @Address("ZERO://CALLBACK")
    public void replyCallback(final Message<Envelop> message) {
        message.reply(Envelop.success("Callback Success"));
    }
```

**限制规则**

* 该模式中使用了Zero的三个核心注解：
    * Agent组件：`io.vertx.up.annotations.EndPoint`。
    * Worker组件：`io.vertx.up.annotations.Queue`。
    * EventBus地址：`io.vertx.up.annotations.Address`。
* EndPoint注解的Agent组件方法不能使用`void`的返回值。
* Worker签名是固定签名规范，返回值**必须是**`void`。

> 完整代码可下载代码后，参考up-rhea项目。

##  「贰」统一模型

&ensp;&ensp;&ensp;&ensp;上述原理解析过程中，图解和代码十分容易理解，稍显复杂的是Zero中定义的**统一数据模型**：`io.vertx.up.commune.Envelop`，该模型充斥在整个Zero环境中，并且可直接在EventBus中传输（重写过Codec），于是它的数据结构就值得我们细细分析了——该数据模型融合了Request-Response过程中所有牵涉的核心数据，成为Zero框架中序列化子系统的核心内部传输模型（下文统一翻译“信封”）。

### 2.1. 数据结构

&ensp;&ensp;&ensp;&ensp;它的核心结构如下：

![](./_image/2021-08-02/2021-08-02-23-05-10.jpg)
&ensp;&ensp;&ensp;&ensp;说明几点：

1. 虚线箭头为「引用」，仅保存了某个复杂Java对象引用，虽然当前**信封**是请求域内的数据消息，但所有**引用**类型对象是单次请求内跨**所有信封**而实现共享——微服务RPC传输、完美转发等所有内部逻辑中会拷贝Envelop而生成新的**信封**，但会保留最初的请求信息。
2. Assist中存储的大部分内容为请求的元数据，由于它是包域，所以不推荐开发人员直接使用，为内部对象，它主要包括：
    * 上下文环境
    * 当前会话
    * 登录用户基本信息
    * HTTP方法和uri地址
    * HTTP请求头
3. Acl在使用时必须提供额外的实现，在`zero-rbac`中提供了`io.vertx.tp.rbac.atom.acl.AclData`实现，有兴趣的读者可以参考它的源代码。该数据结构中的access, edition, fields等信息可自定义，最终根据实现代码决定。

### 2.2. 常用API

&ensp;&ensp;&ensp;&ensp;在分析了Envelop本身的数据结构后，再根据部分场景来看它对应的API相关应用。

> Java Bean规范类型的API此章节不多讲，用于设置获取。

#### 2.2.1. 构造Envelop

&ensp;&ensp;&ensp;&ensp;Envelop没有提供`public`的构造方法，在构造Envelop对象过程中只能使用该类中定义的静态API；不论是**同步**还是**异步**模式，最终都会绑定一个HTTP状态（状态代码和描述文字），Envelop的内部构造函数如：

```java
// 成功的信封
private <T> Envelop(final T data, final HttpStatusCode status)
// 错误的信封
private Envelop(final WebException error)
```

&ensp;&ensp;&ensp;&ensp;根据它的使用场景，有七个常用的静态构造API：

```java
// 状态代码，数据内容
// 成功的信封
Envelop.ok();                         // 204, null
Envelop.okJson();                     // 200, {}
Envelop.success(T);                   // 「常用」200, {}, {}为序列化过后的Json
Envelop.success(T,HttpStatusCode);    // ??, {}, 重载方法，可设置非200的状态代码
// 失败的信封，这种类型的数据部分为WebException序列化后的结果，验证章节提过的异常结构。
Envelop.failure(String);              // 500, {}, 
Envelop.failure(Throwable);           // 「常用」500, {}，将JVM异常封装
Envelop.failure(WebException);        // 「常用」??, {}, WebException中自带Http状态代码
```

#### 2.2.2. 数据读写

#### 2.2.3. 拷贝Envelop

#### 2.2.4. 智能内容

##  「叄」Worker函数签名
