# 始源之地：Vert.x集成

>  考槃在涧，硕人之宽。独寐寤言，永矢弗谖。——佚名《国风·卫风》

* 项目地址：<https://github.com/silentbalanceyh/vertx-zero-example/>（子项目：**up-native**）

## 「壹」Vert.x子项目

&ensp;&ensp;&ensp;&ensp;Vert.x从3.x开始，就将曾经的工具箱重新进行了模块化设计，您可以在官方文档中看到很多相关子项目（2.x中的模块化完全是灾难级的）：

![](./_image/2021-08-06/2021-08-08-18-12-22.png)

&ensp;&ensp;&ensp;&ensp;可能您会困惑，如果使用Zero，是不是就用不了这些相关的子项目了呢？答案是否定的，在Zero中您可以开发**连接点**程序，有了它您可以直接和Vert.x提供的官方子项目集成（类似`MySQL Client`），也可以和Zero中设计的标准插件集成。Zero中的标准插件主要源起于实战，有些插件是Vert.x的子项目未提供的，而两种插件的引入使用统一的模式，Zero的玩法不一定最炫，但铁定会让您眼前一亮！

> `ifx`全称为`infix`，翻译为“中缀、插入”。

&ensp;&ensp;&ensp;&ensp;Zero的子项目`vertx-ifx`中包含了目前支持的所有插件，这些插件的开发流程都遵循了本章节的思路，其中还包含类似**Neo4j**、**ElasticSearch**、**Excel**等官方不支持的集成，一旦您学会了本章的完整开发思路，那么您的项目自然如虎添翼。目前的插件如下表：

|项目名|类型|含义|
|:---|---|:---|
|zero-ifx-es|Zero|ElasticSearch功能模块。|
|zero-ifx-excel|Zero|Excel导入导出功能模块（可直连Jooq功能模块）。|
|zero-ifx-feign|Zero|Feign功能模块。|
|zero-ifx-history|Zero|系统读写日志历史数据库（第二库）。|
|zero-ifx-iqiy|Zero|Qiy爱奇艺视频客户端。|
|zero-ifx-neo4j|Zero|Neo4j的非SQL数据库图库集成模块。|
|zero-ifx-shell|Zero|命令行工具抽象框架。|
|zero-ifx-sms|Zero|阿里云手机短信服务。|
|zero-ifx-native|Vertx|MySQL和PgSQL客户端专用集成（标准）。|
|zero-ifx-mongo|Vertx|Mongo数据库客户端。|
|zero-ifx-redis|Vertx|Redis功能模块。|

&ensp;&ensp;&ensp;&ensp;**表格中的类型**标识了该插件是Vert.x集成插件还是Zero的集成插件，本章不去剖析部分复杂的插件用法，后续会有单独的章节讲解，主要告诉读者：

1. 如何在Zero中开发这种插件项目以及**连接点**程序（如何扩展）。
2. 如何在您的Agent/Worker组件中使用这些扩展。

&ensp;&ensp;&ensp;&ensp;这些插件的设计以**单一职责**为原则，项目本身比较小，代码不多，目的也是让您在选择时可直接根据所需**按需引入**。

### 1.1. MySQL孤岛

#### 1.1.1. 插件分析

&ensp;&ensp;&ensp;&ensp;Zero中使用了MySQL，但由于**动态建模**的影响，并没有使用Vert.x中的`MySQL Client`，而是将Jooq标准化了。有关`MySQL Client`的引入目前存在于`zero-ifx-native`项目中，它只包含了一个代码文件（读者无需自己开发）：

```java
package io.vertx.up.plugin.jdbc;

import io.vertx.core.Vertx;
import io.vertx.ext.asyncsql.MySQLClient;
import io.vertx.ext.sql.SQLClient;
import io.vertx.up.annotations.Plugin;
import io.vertx.up.eon.Plugins;
import io.vertx.up.fn.Fn;
import io.vertx.up.plugin.Infix;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

@Plugin
@SuppressWarnings("unchecked")
public class MySqlInfix implements Infix {

    private static final String NAME = "ZERO_MYSQL_POOL";

    private static final ConcurrentMap<String, SQLClient> CLIENTS
            = new ConcurrentHashMap<>();

    private static void initInternal(final Vertx vertx,
                                     final String name) {
        Fn.pool(CLIENTS, name, () -> 
            Infix.init(
                Plugins.Infix.MYSQL,
                (config) -> MySQLClient.createShared(vertx, config, name),
                MySqlInfix.class
            )
        );
    }

    public static void init(final Vertx vertx) {
        initInternal(vertx, NAME);
    }

    public static SQLClient getClient() {
        return CLIENTS.get(NAME);
    }

    @Override
    public SQLClient get() {
        return getClient();
    }
}
```

&ensp;&ensp;&ensp;&ensp;把它称为**孤岛**，就是因为整个`zero-ifx-native`项目中只有这个文件，而这个文件却包含了很多巧思，也包含了Zero插件结构的骨架代码。
&ensp;&ensp;&ensp;&ensp;接口`io.vertx.up.plugin.Infix`是Zero中为第三方功能模块设计的插件接口，实现该接口的类必须包含两个基本规范：

1. 这是一个插件，必须被@Plugin（`io.vertx.up.annotations.Plugin`）注解。
2. 这个插件必须包含初始化静态方法（根据Vertx实例初始化插件）：

    ```java
    public static void init(final Vertx vertx)
    ```

&ensp;&ensp;&ensp;&ensp;Zero中的插件连接点实现了**池化客户端**，如`MySqlInfix`构造完成后的完整结构如下：

![](./_image/2021-08-06/2021-08-09-09-22-48.jpg)

&ensp;&ensp;&ensp;&ensp;默认情况下，您获取的客户端引用直接和`ZERO_MYSQL_POOL`绑定，Zero中和Vert.x集成的所有`Infix`目前的版本都没扩展**第二客户端**，是否扩展最终取决于您的实际项目需求，上边代码中的插件您可以直接使用。

#### 1.1.2. 插件使用

&ensp;&ensp;&ensp;&ensp;本章讲解如何在Zero中使用`Infix`插件。

&ensp;&ensp;&ensp;&ensp;第一步：先在您的项目`pom.xml`文件中引入该插件的依赖，由于Zero中所有`vertx-ifx`子项目都已经定义过版本，所以可省略`<version>`标签：

```xml
    <dependency>
        <groupId>cn.vertxup</groupId>
        <artifactId>zero-ifx-native</artifactId>
        <!-- 版本部分可省略，如果编译通不过，就使用下边这种。-->
        <version>${zero.version}</version>
    </dependency>
```

&ensp;&ensp;&ensp;&ensp;第二步：然后在项目中书写以下配置文件（以MySQL为例）：

```shell
src/main/resources/vertx.yml
src/main/resources/vertx-inject.yml
src/main/resources/vertx-mysql.yml
```

&ensp;&ensp;&ensp;&ensp;上述三个文件内容如下：

**vertx.yml片段**

```properties
zero:
    # lime专用扩展，默认会读取vertx-inject.yml，所以不需配置它；
    # 此处的mysql表示Zero会去读取vertx-mysql.yml配置文件
    lime: mysql
    vertx:
        instance:
            # 未显示实例列表
```

**vertx-mysql.yml**内容如：

```properties
mysql:
  host: localhost
  port: 3306
  username: root
  password: ????
  database: DB_IOP
```

**vertx-inject.yml**内容如：

```properties
# MySQL插件引入
mysql: io.vertx.up.plugin.jdbc.MySqlInfix
```

&ensp;&ensp;&ensp;&ensp;第三步：完成了上述配置后，您就可以直接在您的Agent或Worker组件中使用`SQLClient`了，参考下边代码：

**Agent代码**

```java
package cn.vertxup.mysql;

import io.vertx.core.json.JsonObject;
import io.vertx.ext.sql.SQLClient;
import io.vertx.up.annotations.EndPoint;
import io.vertx.up.annotations.Plugin;

import javax.inject.infix.MySql;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@EndPoint
@Path("/hi/mysql")
public class MySqlAgent {
    @Plugin
    private transient SQLClient clientA;

    @MySql
    private transient SQLClient clientB;

    @GET
    @Path("/client")
    public JsonObject hiAgent() {
        final JsonObject response = new JsonObject();
        response.put("clientA", this.clientA.toString());
        response.put("clientB", this.clientB.toString());
        return response;
    }
}
```

&ensp;&ensp;&ensp;&ensp;发送请求到地址`/hi/mysql/client`，您可以得到如下响应：

```json
{
    "data": {
        "clientA": "io.vertx.ext.asyncsql.impl.ClientWrapper@225b8ca6",
        "clientB": "io.vertx.ext.asyncsql.impl.ClientWrapper@225b8ca6"
    }
}
```

&ensp;&ensp;&ensp;&ensp;从响应结果可以知道，实际`clientA`和`clientB`引用了同一个对象，在整个环境中，都指向了`ZERO_MYSQL_POOL`绑定的`SQLClient`。上边注解部分的代码使用了依赖注入（Worker和Agent组件中代码相同），如果不使用依赖注入，则您可以使用下边代码获取：

```java
// 这种代码在非Agent/Worker环境中尤其有用，比如工具类中。
final SQLClient client = MySqlInfix.getClient();
```

&ensp;&ensp;&ensp;&ensp;值的注意的是在Vert.x的3.9.8中（不知哪个版本开始），原来的`vertx-mysql-postgresql-client`项目已经被**废弃**了，那是不是本章内容无用了呢？其实不然，虽然废弃了原来的SQLClient，但还引入了`MySQLClient`以及`PgSQLClient`，只是分得更细了，后续版本中我会更新Zero的Vert.x集成部分的代码，将`native`拆成不同的子项目来对待，但整体思路和玩法和本章节的内容保持高度一致，读者就不用去困惑了。

> `javax.inject.infix`包中的注解为保留注解，后续版本扩展时会根据不同功能执行拓展，如果是您自己定义的插件，直接使用标准的`io.vertx.up.annotations.Plugin`即可。

### 1.2. Mongo

&ensp;&ensp;&ensp;&ensp;前一个章节讲解了`zero-ifx-native`项目的内容、用法、以及Zero中**插件**的开发和使用思路，本章节使用同样的思路来分析`zero-ifx-mongo`，这个项目是从最早的手机实战中延生出来的子项目，当初使用了`MongoDB`作为数据库。回到前文思路中，先看看`MongoInfix`的写法：

```java
package io.vertx.tp.plugin.mongo;

import io.vertx.core.Vertx;
import io.vertx.ext.mongo.MongoClient;
import io.vertx.up.annotations.Plugin;
import io.vertx.up.eon.Plugins;
import io.vertx.up.fn.Fn;
import io.vertx.up.plugin.Infix;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

@Plugin
@SuppressWarnings("unchecked")
public class MongoInfix implements Infix {

    private static final String NAME = "ZERO_MONGO_POOL";

    private static final ConcurrentMap<String, MongoClient> CLIENTS
            = new ConcurrentHashMap<>();

    private static void initInternal(final Vertx vertx,
                                     final String name) {
        Fn.pool(CLIENTS, name,() -> 
            Infix.init(
                Plugins.Infix.MONGO,
                (config) -> MongoClient.createShared(vertx, config, name),
                MongoInfix.class
            )
        );
    }

    public static void init(final Vertx vertx) {
        initInternal(vertx, NAME);
    }

    public static MongoClient getClient() {
        return CLIENTS.get(NAME);
    }

    @Override
    public MongoClient get() {
        return getClient();
    }
}
```

&ensp;&ensp;&ensp;&ensp;熟悉的味道、熟悉的配方，有了前一个章节的基础，理解这部分代码轻车熟路。它的基本配置如下：

**Maven中引入**

```xml
    <dependency>
        <groupId>cn.vertxup</groupId>
        <artifactId>zero-ifx-mongo</artifactId>
        <!-- 版本部分可省略，如果编译通不过，就使用下边这种。-->
        <version>${zero.version}</version>
    </dependency>
```

**vertx-mongo.yml**

> 具体配置项可参考官方的MongoOptions。

```properties
mongo:
    db_name: xxx
    post: xxx
    host: xxx
    connection_string: xxxx
    username: xxx
    password: xxx
```

**vertx-inject.yml**

```properties
mongo: io.vertx.tp.plugin.mongo.MongoInfix
```

&ensp;&ensp;&ensp;&ensp;这部分的代码就不详细叙述了，参考下边代码段：

```java
// ..... import 部分
// Mongo客户端引用
import io.vertx.ext.mongo.MongoClient;
// Mongo专用注解
import javax.inject.infix.Mongo;
// ..... 主代码部分
// 插件引用
    @Plugin
    private transient MongoClient clientA;

    @Mongo
    private transient MongoClient clientB;
```

&ensp;&ensp;&ensp;&ensp;如此，您就可以直接在Zero的Agent和Worker组件中直接使用Mongo客户端了，若想要直接在工具类中使用，则可参考：

```java
// 工具类中使用
final MongoClient client = MongoInfix.getClient();
```

### 1.3. Redis

&ensp;&ensp;&ensp;&ensp;Zero目前版本只支持三个和Vert.x集成项目的子项目：

* `zero-ifx-native`：MySQL/PgSQL
* `zero-ifx-mongo`：MongoDB
* `zero-ifx-redis`：Redis

&ensp;&ensp;&ensp;&ensp;本章我们分析一下Redis的基础用法，Redis的**插件**在Zero中是最复杂的，它支持的功能如下：

1. 提供了和Mongo类似的`RedisInfix`实现Redis的异步访问。
2. 引入`Jedis`客户端新增同步访问（适用于旧场景）。
3. 可替换Vert.x Web中的Session存储介质，将`web-session`存储在Redis中替换原生存储。

&ensp;&ensp;&ensp;&ensp;还是回到本章重点`Infix`的代码：

```java
package io.vertx.tp.plugin.redis;

import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.redis.client.Redis;
import io.vertx.redis.client.RedisOptions;
import io.vertx.up.annotations.Plugin;
import io.vertx.up.eon.Plugins;
import io.vertx.up.log.Annal;
import io.vertx.up.plugin.Infix;
import io.vertx.up.util.Ut;
import redis.clients.jedis.Jedis;

import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

@Plugin
@SuppressWarnings("unchecked")
public class RedisInfix implements Infix {

    private static final String NAME = "ZERO_REDIS_POOL";
    private static final Annal LOGGER = Annal.get(RedisInfix.class);

    private static final ConcurrentMap<String, Redis> CLIENTS
            = new ConcurrentHashMap<>();
    private static final ConcurrentMap<String, Jedis> CLIENTS_SYNC
            = new ConcurrentHashMap<>();

    private static void initInternal(final Vertx vertx,
                                     final String name) {
        final RedisOptions options = Infix.init(Plugins.Infix.REDIS,
                /*
                 * Two parts for
                 * - Redis reference
                 * - RedisOptions reference ( For Sync usage )
                 */
                (config) -> new RedisOptions(initSync(name, config)),
                RedisInfix.class);
        /*
         * Redis client processing, ping to check whether it's Ok
         */
        final Redis redis = Redis.createClient(vertx, options);
        CLIENTS.put(name, redis);
        redis.connect(handler -> {
            /*
             * If connected, keep
             * If not connected, remove
             * This kind of operation could let your system synced the Redis
             * instead of Null Pointer in Unit Testing
             */
            if (handler.succeeded()) {
                LOGGER.info("[ Redis ] Connected successfully! {0}", 
                    options.toJson().encode());
            } else {
                final Throwable ex = handler.cause();
                if (Objects.nonNull(ex)) {
                    LOGGER.jvm(ex);
                }
                CLIENTS.remove(name);
            }
        });
    }

    private static JsonObject initSync(
        final String name, 
        final JsonObject options) {
        if (!CLIENTS_SYNC.containsKey(name)) {
            final String host = options.getString("host");
            final Integer port = options.getInteger("port");
            final Jedis client = new Jedis(host, port);
            // Auth
            final String password = options.getString("password");
            if (Ut.notNil(password)) {
                final String username = options.getString("username");
                if (Ut.isNil(username)) {
                    client.auth(password);
                } else {
                    client.auth(username, password);
                }
            }
            try {
                client.ping();
                CLIENTS_SYNC.put(name, client);
            } catch (final Throwable ex) {
                LOGGER.jvm(ex);
            }
        }
        return options;
    }

    public static void init(final Vertx vertx) {
        initInternal(vertx, NAME);
    }

    public static Redis getClient() {
        return CLIENTS.get(NAME);
    }

    public static Jedis getJClient() {
        return CLIENTS_SYNC.get(NAME);
    }

    public static void disabled() {
        CLIENTS.clear();
        CLIENTS_SYNC.clear();
    }

    @Override
    public Redis get() {
        return getClient();
    }
}
```

&ensp;&ensp;&ensp;&ensp;在Redis部分，除了Vert.x集成中引入了新版的Redis异步访问部分，还包含了Jedis的同步访问部分（同步不支持JSR330），二者结合使得功能更加完善，基本代码如下：

**Maven引入**

```xml
    <dependency>
        <groupId>cn.vertxup</groupId>
        <artifactId>zero-ifx-redis</artifactId>
        <!-- 版本部分可省略，如果编译通不过，就使用下边这种。-->
        <version>${zero.version}</version>
    </dependency>
```

**vertx-redis.yml**

```properties
redis:
    post: xxx
    host: xxx
```

**vertx-inject.yml**

```properties
redis: io.vertx.tp.plugin.redis.RedisInfix
```

&ensp;&ensp;&ensp;&ensp;使用部分参考下边代码段：

```java
// ..... import 部分
// Redis客户端引用
import io.vertx.redis.client.Redis;
// Jedis客户端引用
import redis.clients.jedis.Jedis;
// Redis专用注解
import javax.inject.infix.Redis;
// ..... 主代码部分
// 插件引用（注入模式只支持Redis，不支持Jedis）
    @Plugin
    private transient Redis clientA;
    @Redis
    private transient Redis clientB;
// 工具读取（异步）
final Redis client = RedisInfix.getClient();
// 同步唯一获取引用方式
final Jedis client = RedisInfix.getJClient();
```

&ensp;&ensp;&ensp;&ensp;那么到这里，整个Zero中目前牵涉的三个和Vert.x的集成就告一段落，根据本章节的内容，读者可以很快和MySQL、Mongo、Redis集成，并去详细体会Zero中的`Infix`插件的详细内容，后续版本中，我会根据实际项目需求将部分客户端内容标准化，当前版本则提供给读者自己发挥。

>  挑战：最后留一个挑战，您可以尝试自己去开发一个Infix彻底理解Zero中的插件结构。

## 「贰」内置插件

&ensp;&ensp;&ensp;&ensp;除了第一章节表格中枚举的Zero子项目以外，Zero中还有部分内置的`Infix`插件，本章主要讲解一个特殊的内置插件`MapInfix`；和Redis项目插件一样，Zero为了兼容部分遗留系统或老系统，通常都会开**同步**和**异步**双通道来做新旧的桥接，如果只支持异步不支持同步，虽然看起来更加Vert.x，但对很多项目的迁移将是灾难。

### 2.1. MapInfix



## 「叁」小结




